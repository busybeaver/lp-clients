/* tslint:disable */

/** THIS FILE IS AUTOGENERATED FROM THE UMS JSON SCHEMA FILES. DO NOT EDIT MANUALLY. */

import {INotificationsType, INotificationHandler} from "./common_ums";

export type AgentNotifications =
  | MessagingEventNotification
  | ExConversationChangeNotification
  | RoutingTaskNotification
  | AgentStateNotification;
export type MessagingEventNotification = {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * Contains one of the APIs notification type names
   */
  type: string;
  body: any;
  [k: string]: any;
} & {
    type?: string;
    body?: {
      changes: {
        sequence: number;
        originatorId: string;
        metadata?: (ActionReason | BotResponse | IbmWatsonInfo | ExternalId)[];
        serverTimestamp: number;
        event: TextValue | RichContentEvent | HostedFile | ChatStateEvent | AcceptStatusEvent;
        dialogId: string;
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    [k: string]: any;
  };
/**
 * Sent once there is a change in convesation metadata
 */
export type ExConversationChangeNotification = {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * Contains one of the APIs notification type names
   */
  type: string;
  body: any;
  [k: string]: any;
} & {
    type?: "cqm.ExConversationChangeNotification";
    body?: {
      subscriptionId: string;
      changes: {
        type: "UPSERT" | "DELETE";
        result: {
          convId: string;
          conversationDetails: {
            /**
             * Contains the IDs of the conversation participants from each role, both consumers and agents
             */
            participants: {
              id?: string;
              role?: "CONSUMER" | "ASSIGNED_AGENT" | "MANAGER";
              [k: string]: any;
            }[];
            state: "OPEN" | "CLOSE";
            /**
             * Time stamp of the conversation beginning
             */
            startTs: number;
            /**
             * Time stamp of the conversation end
             */
            endTs?: number;
            /**
             * Time To Respond. The contact center response SLA for this conversation
             */
            ttr?: {
              /**
               * A label for the SLA policy
               */
              ttrType: "CUSTOM" | "NORMAL" | "PRIORITIZED" | "URGENT";
              /**
               * Seconds from consumer input till agent response.
               */
              value: number;
              [k: string]: any;
            };
            /**
             * If the contact center is not available, this field indicates until when the handling of the current conversation will be delayed.<br><b>Note: </b> The delay value affects the TTR (see above) calculation. The TTR counts the number of seconds from the consumer response, but if there is a delay the counting will start only from the availablity point of the contact center.
             */
            delay?: {
              /**
               * A label for the delay type
               */
              type: "NIGHT" | "WEEKEND" | "HOLIDAY";
              /**
               * Time stamp of when the contact center will be available again to handle this conversation.
               */
              tillWhen: number;
              [k: string]: any;
            };
            /**
             * Consumer statisfaction information. The data that was submitted by the consumer after the conversation was closed.
             */
            csat?: {
              field: "CSATRate";
              csatRate: 1 | 2 | 3 | 4 | 5;
              csatResolutionConfirmation: boolean;
              status: "FILLED" | "PARTIALLY_FILLED" | "SKIPPED";
              [k: string]: any;
            };
            /**
             * Timestamp of the 'Manual Effective Time To Response'. The agent can manually set the expected timestamp of the next response. This will override any value of the above TTR and Delay fields
             */
            manualETTR?: number;
            [k: string]: any;
          };
          lastUpdateTime: number;
          [k: string]: any;
        };
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    [k: string]: any;
  };
/**
 * Sent once there is a change in a routing task
 */
export type RoutingTaskNotification = {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * Contains one of the APIs notification type names
   */
  type: string;
  body: any;
  [k: string]: any;
} & {
    type?: "routing.routingTaskNotification";
    body?: {
      subscriptionId: string;
      changes: {
        type: "DELETE" | "UPSERT";
        result: {
          taskCompleted: boolean;
          conversationId: string;
          consumerId: string;
          skillId: string;
          ringsDetails: {
            ringId?: string;
            ringExpiration?: number;
            ringState: "ACCEPTED" | "AUTO_ACCEPT" | "CANCELLED" | "EXPIRED" | "REJECTED" | "WAITING";
            weight?: number;
            [k: string]: any;
          }[];
          [k: string]: any;
        };
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    [k: string]: any;
  };
/**
 * Sent once there is a change in the state of the agent
 */
export type AgentStateNotification = {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * Contains one of the APIs notification type names
   */
  type: string;
  body: any;
  [k: string]: any;
} & {
    type?: "routing.agentStateNotification";
    body?: {
      subscriptionId: string;
      changes: {
        type: "UPSERT" | "DELETE";
        result: {
          availability: "AWAY" | "BACK_SOON" | "OFFLINE" | "ONLINE";
          [k: string]: any;
        };
        [k: string]: any;
      }[];
      [k: string]: any;
    };
    [k: string]: any;
  };

/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId {
  type: "ExternalId";
  id: string;
}
export interface TextValue {
  type: string;
  contentType: string;
  message: string;
  [k: string]: any;
}
export interface RichContentEvent {
  type: "RichContentEvent";
  content?: Element;
  [k: string]: any;
}
/**
 * Refer to Structured Content documentation
 */
export interface Element {
  [k: string]: any;
}
export interface HostedFile {
  type: string;
  contentType: string;
  message: {
    caption: string;
    relativePath: string;
    fileType: "IMG" | "JPG" | "PNG" | "GIF" | "TXT" | "PDF";
    preview?: any;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface ChatStateEvent {
  type: string;
  chatState: "ACTIVE" | "INACTIVE" | "GONE" | "COMPOSING" | "PAUSE";
  [k: string]: any;
}
export interface AcceptStatusEvent {
  type: string;
  status: "ACCEPT" | "READ" | "ACCESS" | "NACK" | "ACTION";
  sequenceList: number[];
  [k: string]: any;
}

export const enum AgentNotificationsEvent {
  MessagingEventNotification = "ms.MessagingEventNotification",
  ExConversationChangeNotification = "cqm.ExConversationChangeNotification",
  routingTaskNotification = "routing.routingTaskNotification",
  agentStateNotification = "routing.agentStateNotification"
}

export interface IAgentNotificationsType extends INotificationsType<AgentNotifications> {
  "ms.MessagingEventNotification": MessagingEventNotification;
  "cqm.ExConversationChangeNotification": ExConversationChangeNotification;
  "routing.routingTaskNotification": RoutingTaskNotification;
  "routing.agentStateNotification": AgentStateNotification;
}

export type AgentNotificationsType = "ms.MessagingEventNotification" | "cqm.ExConversationChangeNotification" | "routing.routingTaskNotification" | "routing.agentStateNotification";

export const AgentNotificationsEvents = ["MessagingEventNotification", "ExConversationChangeNotification", "routingTaskNotification", "agentStateNotification"], AgentNotificationsTypes = ["ms.MessagingEventNotification", "cqm.ExConversationChangeNotification", "routing.routingTaskNotification", "routing.agentStateNotification"];

export type Constructor<T extends INotificationHandler<IAgentNotificationsType, AgentNotifications>> = new (...args: any[]) => T;

export class AgentNotificationsWrapper extends Base {
  constructor(...args) {
    super(...args);
  }

  onMessagingEventNotification(cb: (notification: MessagingEventNotification) => void): void {
    this.onNotification(AgentNotificationsEvent.MessagingEventNotification, cb);
  }

  onExConversationChangeNotification(cb: (notification: ExConversationChangeNotification) => void): void {
    this.onNotification(AgentNotificationsEvent.ExConversationChangeNotification, cb);
  }

  onRoutingTaskNotification(cb: (notification: RoutingTaskNotification) => void): void {
    this.onNotification(AgentNotificationsEvent.routingTaskNotification, cb);
  }

  onAgentStateNotification(cb: (notification: AgentStateNotification) => void): void {
    this.onNotification(AgentNotificationsEvent.agentStateNotification, cb);
  }
}

export function wrapAgentNotifications<T extends Constructor<INotificationHandler<IAgentNotificationsType, AgentNotifications>>>(Base: T) {

  return AgentNotificationsWrapper;
}
