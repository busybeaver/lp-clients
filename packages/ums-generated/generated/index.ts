/* tslint:disable */

/** THIS FILE IS AUTOGENERATED FROM THE UMS JSON SCHEMA FILES. DO NOT EDIT MANUALLY. */

import { Omit } from "type-zoo";

export type UmsSchema =
  | MessagingEventNotification
  | ExConversationChangeNotification
  | RoutingTaskNotification
  | AgentStateNotification
  | RequestConversationResponse
  | StringResp
  | PublishEventResponse
  | GenericSubscribeResponse
  | GetUserProfileResponse
  | SubscribeExConversationsResponse
  | MessagingEventNotification1
  | InitConnection
  | UpdateConversationField
  | ConsumerRequestConversation
  | PublishEvent
  | SubscribeMessagingEvents
  | SubscribeExConversations
  | UnsubscribeExConversations;

export interface MessagingEventNotification extends INotificationType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * Contains one of the APIs notification type names
   */
  type: string;
  body: {
    changes: {
      sequence: number;
      originatorId: string;
      metadata?: (ActionReason | BotResponse | IbmWatsonInfo | ExternalId)[];
      serverTimestamp: number;
      event: TextValue | RichContentEvent | HostedFile | ChatStateEvent | AcceptStatusEvent;
      dialogId: string;
      [k: string]: any;
    }[];
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId {
  type: "ExternalId";
  id: string;
}
export interface TextValue {
  type: string;
  contentType: string;
  message: string;
  [k: string]: any;
}
export interface RichContentEvent {
  type: "RichContentEvent";
  content?: Element;
  [k: string]: any;
}
/**
 * Refer to Structured Content documentation
 */
export interface Element {
  [k: string]: any;
}
export interface HostedFile {
  type: string;
  contentType: string;
  message: {
    caption: string;
    relativePath: string;
    fileType: "IMG" | "JPG" | "PNG" | "GIF" | "TXT" | "PDF";
    preview?: any;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface ChatStateEvent {
  type: string;
  chatState: "ACTIVE" | "INACTIVE" | "GONE" | "COMPOSING" | "PAUSE";
  [k: string]: any;
}
export interface AcceptStatusEvent {
  type: string;
  status: "ACCEPT" | "READ" | "ACCESS" | "NACK" | "ACTION";
  sequenceList: number[];
  [k: string]: any;
}
/**
 * Sent once there is a change in convesation metadata
 */
export interface ExConversationChangeNotification extends INotificationType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * Contains one of the APIs notification type names
   */
  type: "cqm.ExConversationChangeNotification";
  body: {
    subscriptionId: string;
    changes: {
      type: "UPSERT" | "DELETE";
      result: {
        convId: string;
        conversationDetails: {
          /**
           * Contains the IDs of the conversation participants from each role, both consumers and agents
           */
          participants: {
            id?: string;
            role?: "CONSUMER" | "ASSIGNED_AGENT" | "MANAGER";
            [k: string]: any;
          }[];
          state: "OPEN" | "CLOSE";
          /**
           * Time stamp of the conversation beginning
           */
          startTs: number;
          /**
           * Time stamp of the conversation end
           */
          endTs?: number;
          /**
           * Time To Respond. The contact center response SLA for this conversation
           */
          ttr?: {
            /**
             * A label for the SLA policy
             */
            ttrType: "CUSTOM" | "NORMAL" | "PRIORITIZED" | "URGENT";
            /**
             * Seconds from consumer input till agent response.
             */
            value: number;
            [k: string]: any;
          };
          /**
           * If the contact center is not available, this field indicates until when the handling of the current conversation will be delayed.<br><b>Note: </b> The delay value affects the TTR (see above) calculation. The TTR counts the number of seconds from the consumer response, but if there is a delay the counting will start only from the availablity point of the contact center.
           */
          delay?: {
            /**
             * A label for the delay type
             */
            type: "NIGHT" | "WEEKEND" | "HOLIDAY";
            /**
             * Time stamp of when the contact center will be available again to handle this conversation.
             */
            tillWhen: number;
            [k: string]: any;
          };
          /**
           * Consumer statisfaction information. The data that was submitted by the consumer after the conversation was closed.
           */
          csat?: {
            field: "CSATRate";
            csatRate: 1 | 2 | 3 | 4 | 5;
            csatResolutionConfirmation: boolean;
            status: "FILLED" | "PARTIALLY_FILLED" | "SKIPPED";
            [k: string]: any;
          };
          /**
           * Timestamp of the 'Manual Effective Time To Response'. The agent can manually set the expected timestamp of the next response. This will override any value of the above TTR and Delay fields
           */
          manualETTR?: number;
          [k: string]: any;
        };
        lastUpdateTime: number;
        [k: string]: any;
      };
      [k: string]: any;
    }[];
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Sent once there is a change in a routing task
 */
export interface RoutingTaskNotification extends INotificationType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * Contains one of the APIs notification type names
   */
  type: "routing.routingTaskNotification";
  body: {
    subscriptionId: string;
    changes: {
      type: "DELETE" | "UPSERT";
      result: {
        taskCompleted: boolean;
        conversationId: string;
        consumerId: string;
        skillId: string;
        ringsDetails: {
          ringId?: string;
          ringExpiration?: number;
          ringState: "ACCEPTED" | "AUTO_ACCEPT" | "CANCELLED" | "EXPIRED" | "REJECTED" | "WAITING";
          weight?: number;
          [k: string]: any;
        }[];
        [k: string]: any;
      };
      [k: string]: any;
    }[];
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Sent once there is a change in the state of the agent
 */
export interface AgentStateNotification extends INotificationType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * Contains one of the APIs notification type names
   */
  type: "routing.agentStateNotification";
  body: {
    subscriptionId: string;
    changes: {
      type: "UPSERT" | "DELETE";
      result: {
        availability: "AWAY" | "BACK_SOON" | "OFFLINE" | "ONLINE";
        [k: string]: any;
      };
      [k: string]: any;
    }[];
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Upon successful conversation creation, this reponse will be sent by the server
 */
export interface RequestConversationResponse extends IResponseType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * The ID of the request that originated this response
   */
  reqId: string;
  /**
   * Contains one of the APIs response type names
   */
  type: string;
  /**
   * Response code according to the HTTP status codes standard
   */
  code: number;
  body: {
    /**
     * The ID of the generated conversation
     */
    conversationId: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * General response message with string description.
 */
export interface StringResp extends IResponseType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * The ID of the request that originated this response
   */
  reqId: string;
  /**
   * Contains one of the APIs response type names
   */
  type: string;
  /**
   * Response code according to the HTTP status codes standard
   */
  code: number;
  /**
   * Optional text description for the response
   */
  body: string;
  [k: string]: any;
}
export interface PublishEventResponse extends IResponseType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * The ID of the request that originated this response
   */
  reqId: string;
  /**
   * Contains one of the APIs response type names
   */
  type: string;
  /**
   * Response code according to the HTTP status codes standard
   */
  code: number;
  body: {
    /**
     * content and read receipt events get a sequential ID in the conversation.
     */
    sequence?: number;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GenericSubscribeResponse extends IResponseType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * The ID of the request that originated this response
   */
  reqId: string;
  /**
   * Contains one of the APIs response type names
   */
  type: string;
  /**
   * Response code according to the HTTP status codes standard
   */
  code: number;
  body: {
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Gets customer and personal info for the given consumerId.
 */
export interface GetUserProfileResponse extends IResponseType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * The ID of the request that originated this response
   */
  reqId: string;
  /**
   * Contains one of the APIs response type names
   */
  type: "up.GetUserProfile$Response";
  /**
   * Response code according to the HTTP status codes standard
   */
  code: number;
  body: (CustomerInfo | PersonalInfo)[];
  [k: string]: any;
}
/**
 * Customer Infomration
 */
export interface CustomerInfo {
  type: string;
  auth?: {
    amr?: (
      | "face"
      | "fpt"
      | "geo"
      | "hwk"
      | "iris"
      | "kba"
      | "mca"
      | "mfa"
      | "otp"
      | "pin"
      | "pwd"
      | "rba"
      | "retina"
      | "sc"
      | "sms"
      | "swk"
      | "tel"
      | "user"
      | "vbm"
      | "wia")[];
    /**
     * Issuer URI
     */
    iss?: string;
    [k: string]: any;
  };
  info: {
    /**
     * CUSTOMER LIFECYCLE STATUS. FROM PRE-DEFINED LIST.
     */
    cstatus?: string;
    /**
     * CUSTOMER TYPE OR TIER. FROM PRE-DEFINED LIST
     */
    ctype?: string;
    /**
     * UNIQUE CUSTOMER IDENTIFIER
     */
    customerId?: string;
    /**
     * THE CUSTOMER FINANCIAL BALANCE IN DECIMAL VALUE
     */
    balance?: number;
    /**
     * SOCIAL ID OF YOUR CHOICE: FACEBOOK, TWITTER ETC...
     */
    socialId?: string;
    /**
     * UNIQUE DEVICE OR PHONE IDENTIFIER
     */
    imei?: string;
    /**
     * CONSUMER NICKNAME OR USERNAME
     */
    userName?: string;
    /**
     * COMPANY SIZE MEASURED BY NUMBER OF EMPLOYEES
     */
    companySize?: number;
    /**
     * THE CUSTOMER'S COMPANY NAME
     */
    accountName?: string;
    /**
     * CONSUMER ROLE TITLE
     */
    role?: string;
    lastPaymentDate?: {
      day: number;
      month: number;
      year: number;
      [k: string]: any;
    };
    registrationDate?: {
      day: number;
      month: number;
      year: number;
      [k: string]: any;
    };
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Personal Infomration
 */
export interface PersonalInfo {
  type: string;
  auth?: {
    amr?: (
      | "face"
      | "fpt"
      | "geo"
      | "hwk"
      | "iris"
      | "kba"
      | "mca"
      | "mfa"
      | "otp"
      | "pin"
      | "pwd"
      | "rba"
      | "retina"
      | "sc"
      | "sms"
      | "swk"
      | "tel"
      | "user"
      | "vbm"
      | "wia")[];
    /**
     * Issuer URI
     */
    iss?: string;
    [k: string]: any;
  };
  personal: {
    firstname?: string;
    lastname?: string;
    age?: {
      age?: number;
      year?: number;
      month?: number;
      day?: number;
      [k: string]: any;
    };
    contacts?: {
      email?: string;
      phone?: string;
      [k: string]: any;
    }[];
    gender?: "MALE" | "FEMALE" | "OTHER";
    language?: string;
    /**
     * Company name.
     */
    company?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface SubscribeExConversationsResponse extends IResponseType {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * The ID of the request that originated this response
   */
  reqId: string;
  /**
   * Contains one of the APIs response type names
   */
  type: string;
  /**
   * Response code according to the HTTP status codes standard
   */
  code: number;
  body: {
    subscriptionId: string;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface MessagingEventNotification1 {
  /**
   * Defines that the message is a response
   */
  kind: string;
  /**
   * Contains one of the APIs notification type names
   */
  type: "ms.MessagingEventNotification";
  body: {
    changes: {
      sequence: number;
      originatorId: string;
      metadata?: (ActionReason1 | BotResponse1 | IbmWatsonInfo1 | ExternalId1)[];
      serverTimestamp: number;
      event: TextValue1 | RichContentEvent1 | HostedFile1 | ChatStateEvent1 | AcceptStatusEvent1;
      dialogId: string;
      [k: string]: any;
    }[];
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason1 {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse1 {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo1 {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId1 {
  type: "ExternalId";
  id: string;
}
export interface TextValue1 {
  type: string;
  contentType: string;
  message: string;
  [k: string]: any;
}
export interface RichContentEvent1 {
  type: "RichContentEvent";
  content?: Element1;
  [k: string]: any;
}
/**
 * Refer to Structured Content documentation
 */
export interface Element1 {
  [k: string]: any;
}
export interface HostedFile1 {
  type: string;
  contentType: string;
  message: {
    caption: string;
    relativePath: string;
    fileType: "IMG" | "JPG" | "PNG" | "GIF" | "TXT" | "PDF";
    preview?: any;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface ChatStateEvent1 {
  type: string;
  chatState: "ACTIVE" | "INACTIVE" | "GONE" | "COMPOSING" | "PAUSE";
  [k: string]: any;
}
export interface AcceptStatusEvent1 {
  type: string;
  status: "ACCEPT" | "READ" | "ACCESS" | "NACK" | "ACTION";
  sequenceList: number[];
  [k: string]: any;
}
/**
 * This request is needed only for clients that cannot send websocket headers. It can include the authentication and the clientProperties information.
 */
export interface InitConnection extends ISendType {
  /**
   * Defines that the message is a request
   */
  kind?: string;
  /**
   * Request ID generated by the client. It should be unique per WebSocket session in order to identify the request. This ID will be reflected by the server in the response to the request.
   */
  id: string;
  /**
   * Contains one of the APIs request type names
   */
  type: "InitConnection";
  metadata?: (ActionReason2 | BotResponse2 | IbmWatsonInfo2 | ExternalId2)[];
  headers: (ClientProperties | ConsumerAuthentication)[];
  [k: string]: any;
}
/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason2 {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse2 {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo2 {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId2 {
  type: "ExternalId";
  id: string;
}
/**
 * Information about the client: hardware, software, timeZone, IP etc...
 */
export interface ClientProperties {
  type: ".ams.headers.ClientProperties";
  /**
   * Identifies the application
   */
  appId?: string;
  /**
   * The application version, for example, in the case of mobile it will be the host app version
   */
  appVersion?: string;
  ipAddress?: string;
  deviceFamily?: "DESKTOP" | "TABLET" | "MOBILE" | "OTHER";
  os?: "WINDOWS" | "LINUX" | "OSX" | "ANDROID" | "IOS" | "OTHER";
  /**
   * Specifies the operating system version, and distribution type (if relevant)
   *  Examples: Ubuntu 15.00
   */
  osVersion?: string;
  /**
   * OS name is a text describing the operating system
   *  Examples: WindowsXP
   */
  osName?: string;
  integration?: "WEB_SDK" | "MOBILE_SDK" | "BRAND_SDK";
  integrationVersion?: string;
  /**
   * For example: chrome, firefox, etc...
   */
  browser?: string;
  /**
   * Detailed version info of the user agent (browser or host-application)
   */
  browserVersion?: string;
  /**
   * For example: "America/Los_Angeles"
   */
  timeZone?: string;
  /**
   * For example LG, HP, Microsoft....
   */
  deviceManufacture?: string;
  /**
   * For example for G3 for LG, iPhone6s for Apple...
   */
  deviceModel?: string;
  /**
   * Some of the client capablities are not supported by default. In order to enable them, the client should include the feature name in this field.
   */
  features?: ("CO_BROWSE" | "CO_APP" | "PHOTO_SHARING" | "SECURE_FORMS" | "AUTO_MESSAGES" | "RICH_CONTENT")[];
  [k: string]: any;
}
/**
 * Information about the client: hardware, software, timeZone, IP etc...
 */
export interface ConsumerAuthentication {
  type: ".ams.headers.ConsumerAuthentication";
  /**
   * jwt issued by LivePerson idp service for this consumer
   */
  jwt: string;
  [k: string]: any;
}
export interface UpdateConversationField extends ISendType {
  /**
   * Defines that the message is a request
   */
  kind?: string;
  /**
   * Request ID generated by the client. It should be unique per WebSocket session in order to identify the request. This ID will be reflected by the server in the response to the request.
   */
  id: string;
  /**
   * Contains one of the APIs request type names
   */
  type: "cm.UpdateConversationField";
  metadata?: (ActionReason3 | BotResponse3 | IbmWatsonInfo3 | ExternalId3)[];
  /**
   * Updates conversation metadata like: state, CSAT, TimeToRespond police etc... Consumer and agent might have different permissions.
   */
  body: {
    conversationId: string;
    conversationField: (StateChange | ParticipantsChangeForAgents | SkillChange | TtrChange | CsatChange)[];
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason3 {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse3 {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo3 {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId3 {
  type: "ExternalId";
  id: string;
}
export interface StateChange {
  field: "ConversationStateField";
  conversationState: "CLOSE";
  [k: string]: any;
}
export interface ParticipantsChangeForAgents {
  field: "ParticipantsChange";
  type: "ADD" | "REMOVE" | "UPDATE";
  role: "MANAGER" | "READER" | "ASSIGNED_AGENT";
  [k: string]: any;
}
export interface SkillChange {
  field: "Skill";
  type: "UPDATE";
  skill: string;
  [k: string]: any;
}
export interface TtrChange {
  field: "TTRField";
  /**
   * Label for the given TTR
   */
  ttrType: "CUSTOM" | "NORMAL" | "PRIORITIZED" | "URGENT";
  /**
   * Seconds from consumer input till agent response
   */
  value: number;
  [k: string]: any;
}
/**
 * Consumer satisfaction information. The data that was submitted by the consumer after the conversation was closed.
 */
export interface CsatChange {
  field: "CSATRate";
  csatRate: 1 | 2 | 3 | 4 | 5;
  csatResolutionConfirmation: boolean;
  status: "FILLED" | "PARTIALLY_FILLED" | "SKIPPED";
  [k: string]: any;
}
/**
 * This request is used by the consumer to request a new conversation
 */
export interface ConsumerRequestConversation extends ISendType {
  /**
   * Defines that the message is a request
   */
  kind?: string;
  /**
   * Request ID generated by the client. It should be unique per WebSocket session in order to identify the request. This ID will be reflected by the server in the response to the request.
   */
  id: string;
  /**
   * Contains one of the APIs request type names
   */
  type: "cm.ConsumerRequestConversation";
  metadata?: (ActionReason4 | BotResponse4 | IbmWatsonInfo4 | ExternalId4)[];
  [k: string]: any;
}
/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason4 {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse4 {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo4 {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId4 {
  type: "ExternalId";
  id: string;
}
/**
 * Publishes events to existing dialog. Events can be: <ul><li>text-content</li><li>rich-content (structured content) - for more information about the supported structured content templates please refer to the Structured Content Templates page.</li><li>photo-reference-content</li><li>read-reciepts (accept status)</li><li>presense/typing events (chat-state)</li></ul>
 */
export interface PublishEvent extends ISendType {
  /**
   * Defines that the message is a request
   */
  kind?: string;
  /**
   * Request ID generated by the client. It should be unique per WebSocket session in order to identify the request. This ID will be reflected by the server in the response to the request.
   */
  id: string;
  /**
   * Contains one of the APIs request type names
   */
  type: "ms.PublishEvent";
  metadata?: (ActionReason5 | BotResponse5 | IbmWatsonInfo5 | ExternalId5)[];
  body: {
    dialogId: string;
    event: TextValue2 | RichContentEvent2 | HostedFile2 | ChatStateEvent2 | AcceptStatusEvent2;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason5 {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse5 {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo5 {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId5 {
  type: "ExternalId";
  id: string;
}
export interface TextValue2 {
  type: string;
  contentType: string;
  message: string;
  [k: string]: any;
}
export interface RichContentEvent2 {
  type: "RichContentEvent";
  content?: Element2;
  [k: string]: any;
}
/**
 * Refer to Structured Content documentation
 */
export interface Element2 {
  [k: string]: any;
}
export interface HostedFile2 {
  type: string;
  contentType: string;
  message: {
    caption: string;
    relativePath: string;
    fileType: "IMG" | "JPG" | "PNG" | "GIF" | "TXT" | "PDF";
    preview?: any;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface ChatStateEvent2 {
  type: string;
  chatState: "ACTIVE" | "INACTIVE" | "GONE" | "COMPOSING" | "PAUSE";
  [k: string]: any;
}
export interface AcceptStatusEvent2 {
  type: string;
  status: "ACCEPT" | "READ" | "ACCESS" | "NACK" | "ACTION";
  sequenceList: number[];
  [k: string]: any;
}
/**
 * Subscribes to get the events of a conversation. Existing events will be sent immediately, while new events will be notified as they happen.
 */
export interface SubscribeMessagingEvents extends ISendType {
  /**
   * Defines that the message is a request
   */
  kind?: string;
  /**
   * Request ID generated by the client. It should be unique per WebSocket session in order to identify the request. This ID will be reflected by the server in the response to the request.
   */
  id: string;
  /**
   * Contains one of the APIs request type names
   */
  type: "ms.SubscribeMessagingEvents";
  metadata?: (ActionReason6 | BotResponse6 | IbmWatsonInfo6 | ExternalId6)[];
  body: {
    /**
     * Fetch events with sequence greater or equal to this value
     */
    fromSeq?: number;
    dialogId: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason6 {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse6 {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo6 {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId6 {
  type: "ExternalId";
  id: string;
}
/**
 * Subscribes to any changes in the medata of the conversations of this user. Existing conversations that matches the filter will also be sent.<h4>Responses</h4><ul><li>200: SubscribeExConversationsResponse</li><li>Notification: ExConversationChangeNotification</li></ul>
 */
export interface SubscribeExConversations extends ISendType {
  /**
   * Defines that the message is a request
   */
  kind?: string;
  /**
   * Request ID generated by the client. It should be unique per WebSocket session in order to identify the request. This ID will be reflected by the server in the response to the request.
   */
  id: string;
  /**
   * Contains one of the APIs request type names
   */
  type: "cqm.SubscribeExConversations";
  metadata?: (ActionReason7 | BotResponse7 | IbmWatsonInfo7 | ExternalId7)[];
  body?: {
    /**
     * Do not fetch conversation which have not been updated after this timestamp
     */
    minLastUpdatedTime?: number;
    convState?: ("OPEN" | "CLOSE")[];
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason7 {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse7 {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo7 {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId7 {
  type: "ExternalId";
  id: string;
}
/**
 * Unsubcribes the user from getting notifications on conversation metadata changes.
 */
export interface UnsubscribeExConversations extends ISendType {
  /**
   * Defines that the message is a request
   */
  kind?: string;
  /**
   * Request ID generated by the client. It should be unique per WebSocket session in order to identify the request. This ID will be reflected by the server in the response to the request.
   */
  id: string;
  /**
   * Contains one of the APIs request type names
   */
  type: "cqm.UnsubscribeExConversations";
  metadata?: (ActionReason8 | BotResponse8 | IbmWatsonInfo8 | ExternalId8)[];
  body: {
    subscriptionId: string;
    [k: string]: any;
  };
  [k: string]: any;
}
/**
 * Reason information while the conversation is being escalated by a bot to a human agent
 */
export interface ActionReason8 {
  type: "ActionReason";
  reasonId?: string;
  reason?: string;
}
/**
 * Information coming back from the bot provider
 */
export interface BotResponse8 {
  type: "BotResponse";
  externalConversationId?: string;
  businessCases?: string[];
  intents?: {
    name?: string;
    id: string;
    confidence: number;
    [k: string]: any;
  }[];
}
/**
 * Information coming back from the IBM Watson virtual agent
 */
export interface IbmWatsonInfo8 {
  type: "IBMWatsonInfo";
  branch_exited?: boolean;
  branch_exited_reason?: string;
  capability?: string;
  nodes_visited?: string[];
  referred_capability?: string;
  referred_nodes?: string[];
  referred_visitor_message_sequences: number[];
  entities?: {
    entity?: string;
    location?: number[];
    value?: string;
    [k: string]: any;
  }[];
}
/**
 * External id of the action was made
 */
export interface ExternalId8 {
  type: "ExternalId";
  id: string;
}

export interface ITyped {
  type: string;
}

export interface ISendType extends ITyped {
  id: string;
}

export interface IResponseType extends ITyped {
  reqId: string;
}

export interface INotificationType extends ITyped {
}

export type INotificationsType<NotificationType extends INotificationType> = { [key: string]: NotificationType };

export interface INotificationHandler<NotificationTypes extends INotificationsType<NotificationType>, NotificationType extends INotificationType> {
  onNotification<K extends keyof NotificationTypes>(notificationType: K, cb: (notification: NotificationTypes[K]) => void): void;
}

export interface ISendHandler<SendType extends ISendType, ResponseType extends IResponseType> {
  sendMessage(req: SendType): Promise<ResponseType>;
}

export type ConsumerRequests = InitConnection | UpdateConversationField | ConsumerRequestConversation | PublishEvent | SubscribeMessagingEvents | SubscribeExConversations | UnsubscribeExConversations;

export const enum ConsumerRequestsEvent {
  InitConnection = "InitConnection",
  UpdateConversationField = "cm.UpdateConversationField",
  ConsumerRequestConversation = "cm.ConsumerRequestConversation",
  PublishEvent = "ms.PublishEvent",
  SubscribeMessagingEvents = "ms.SubscribeMessagingEvents",
  SubscribeExConversations = "cqm.SubscribeExConversations",
  UnsubscribeExConversations = "cqm.UnsubscribeExConversations"
}

export interface IConsumerRequestsType {
  "InitConnection": InitConnection;
  "cm.UpdateConversationField": UpdateConversationField;
  "cm.ConsumerRequestConversation": ConsumerRequestConversation;
  "ms.PublishEvent": PublishEvent;
  "ms.SubscribeMessagingEvents": SubscribeMessagingEvents;
  "cqm.SubscribeExConversations": SubscribeExConversations;
  "cqm.UnsubscribeExConversations": UnsubscribeExConversations;
}

export type ConsumerRequestsType = "InitConnection" | "cm.UpdateConversationField" | "cm.ConsumerRequestConversation" | "ms.PublishEvent" | "ms.SubscribeMessagingEvents" | "cqm.SubscribeExConversations" | "cqm.UnsubscribeExConversations";

export const ConsumerRequestsEvents = ["InitConnection", "UpdateConversationField", "ConsumerRequestConversation", "PublishEvent", "SubscribeMessagingEvents", "SubscribeExConversations", "UnsubscribeExConversations"], ConsumerRequestsTypes = ["InitConnection", "cm.UpdateConversationField", "cm.ConsumerRequestConversation", "ms.PublishEvent", "ms.SubscribeMessagingEvents", "cqm.SubscribeExConversations", "cqm.UnsubscribeExConversations"];

export type ConsumerResponses = RequestConversationResponse | StringResp | PublishEventResponse | GenericSubscribeResponse | SubscribeExConversationsResponse;

export const enum ConsumerResponsesEvent {
  RequestConversationResponse = "cm.RequestConversationResponse",
  StringResp = ".ReqBody$StringResp",
  PublishEventResponse = "ms.PublishEventResponse",
  GenericSubscribeResponse = "GenericSubscribeResponse",
  SubscribeExConversationsResponse = "cqm.SubscribeExConversationsResponse"
}

export interface IConsumerResponsesType {
  "cm.RequestConversationResponse": RequestConversationResponse;
  ".ReqBody$StringResp": StringResp;
  "ms.PublishEventResponse": PublishEventResponse;
  "GenericSubscribeResponse": GenericSubscribeResponse;
  "cqm.SubscribeExConversationsResponse": SubscribeExConversationsResponse;
}

export type ConsumerResponsesType = "cm.RequestConversationResponse" | ".ReqBody$StringResp" | "ms.PublishEventResponse" | "GenericSubscribeResponse" | "cqm.SubscribeExConversationsResponse";

export const ConsumerResponsesEvents = ["RequestConversationResponse", "StringResp", "PublishEventResponse", "GenericSubscribeResponse", "SubscribeExConversationsResponse"], ConsumerResponsesTypes = ["cm.RequestConversationResponse", ".ReqBody$StringResp", "ms.PublishEventResponse", "GenericSubscribeResponse", "cqm.SubscribeExConversationsResponse"];

export interface IConsumerResponsesWrapper {
  doInitConnection(data: Omit<InitConnection, "type">): Promise<StringResp>;
  doUpdateConversationField(data: Omit<UpdateConversationField, "type">): Promise<StringResp>;
  doConsumerRequestConversation(data: Omit<ConsumerRequestConversation, "type">): Promise<RequestConversationResponse>;
  doPublishEvent(data: Omit<PublishEvent, "type">): Promise<PublishEventResponse>;
  doSubscribeMessagingEvents(data: Omit<SubscribeMessagingEvents, "type">): Promise<GenericSubscribeResponse>;
  doSubscribeExConversations(data: Omit<SubscribeExConversations, "type">): Promise<SubscribeExConversationsResponse>;
  doUnsubscribeExConversations(data: Omit<UnsubscribeExConversations, "type">): Promise<StringResp>;
}

export type ConsumerResponsesConstructor<T extends ISendHandler<ConsumerRequests, ConsumerResponses>> = new (...args: any[]) => T;
export type ConsumerResponsesWrapperConstructor = new (...args: any[]) => IConsumerResponsesWrapper;
export type ConsumerNotifications = MessagingEventNotification | ExConversationChangeNotification;

export const enum ConsumerNotificationsEvent {
  MessagingEventNotification = "ms.MessagingEventNotification",
  ExConversationChangeNotification = "cqm.ExConversationChangeNotification"
}

export interface IConsumerNotificationsType extends INotificationsType<ConsumerNotifications> {
  "ms.MessagingEventNotification": MessagingEventNotification;
  "cqm.ExConversationChangeNotification": ExConversationChangeNotification;
}

export type ConsumerNotificationsType = "ms.MessagingEventNotification" | "cqm.ExConversationChangeNotification";

export const ConsumerNotificationsEvents = ["MessagingEventNotification", "ExConversationChangeNotification"], ConsumerNotificationsTypes = ["ms.MessagingEventNotification", "cqm.ExConversationChangeNotification"];

export type ConsumerNotificationsConstructor<T extends INotificationHandler<IConsumerNotificationsType, ConsumerNotifications>> = new (...args: any[]) => T;
export type ConsumerNotificationsWrapperConstructor = new (...args: any[]) => IConsumerNotificationsWrapper;

export interface IConsumerNotificationsWrapper {
  onMessagingEventNotification(cb: (notification: MessagingEventNotification) => void): void;
  onExConversationChangeNotification(cb: (notification: ExConversationChangeNotification) => void): void;
}

export function wrapConsumerNotifications<T extends ConsumerNotificationsConstructor<INotificationHandler<IConsumerNotificationsType, ConsumerNotifications>>>(Base: T): T & ConsumerNotificationsWrapperConstructor {

  class ConsumerNotificationsWrapper extends Base implements IConsumerNotificationsWrapper {
    constructor(...args) {
      super(...args);
    }

    public onMessagingEventNotification(cb: (notification: MessagingEventNotification) => void): void {
      this.onNotification(ConsumerNotificationsEvent.MessagingEventNotification, cb);
    }

    public onExConversationChangeNotification(cb: (notification: ExConversationChangeNotification) => void): void {
      this.onNotification(ConsumerNotificationsEvent.ExConversationChangeNotification, cb);
    }
  }
  return ConsumerNotificationsWrapper;
}

export type AgentResponses = RequestConversationResponse | StringResp | PublishEventResponse | GenericSubscribeResponse | GetUserProfileResponse | SubscribeExConversationsResponse;

export const enum AgentResponsesEvent {
  RequestConversationResponse = "cm.RequestConversationResponse",
  StringResp = ".ReqBody$StringResp",
  PublishEventResponse = "ms.PublishEventResponse",
  GenericSubscribeResponse = "GenericSubscribeResponse",
  GetUserProfileResponse = "up.GetUserProfile$Response",
  SubscribeExConversationsResponse = "cqm.SubscribeExConversationsResponse"
}

export interface IAgentResponsesType {
  "cm.RequestConversationResponse": RequestConversationResponse;
  ".ReqBody$StringResp": StringResp;
  "ms.PublishEventResponse": PublishEventResponse;
  "GenericSubscribeResponse": GenericSubscribeResponse;
  "up.GetUserProfile$Response": GetUserProfileResponse;
  "cqm.SubscribeExConversationsResponse": SubscribeExConversationsResponse;
}

export type AgentResponsesType = "cm.RequestConversationResponse" | ".ReqBody$StringResp" | "ms.PublishEventResponse" | "GenericSubscribeResponse" | "up.GetUserProfile$Response" | "cqm.SubscribeExConversationsResponse";

export const AgentResponsesEvents = ["RequestConversationResponse", "StringResp", "PublishEventResponse", "GenericSubscribeResponse", "GetUserProfileResponse", "SubscribeExConversationsResponse"], AgentResponsesTypes = ["cm.RequestConversationResponse", ".ReqBody$StringResp", "ms.PublishEventResponse", "GenericSubscribeResponse", "up.GetUserProfile$Response", "cqm.SubscribeExConversationsResponse"];

export type AgentNotifications = MessagingEventNotification | ExConversationChangeNotification | RoutingTaskNotification | AgentStateNotification;

export const enum AgentNotificationsEvent {
  MessagingEventNotification = "ms.MessagingEventNotification",
  ExConversationChangeNotification = "cqm.ExConversationChangeNotification",
  routingTaskNotification = "routing.routingTaskNotification",
  agentStateNotification = "routing.agentStateNotification"
}

export interface IAgentNotificationsType extends INotificationsType<AgentNotifications> {
  "ms.MessagingEventNotification": MessagingEventNotification;
  "cqm.ExConversationChangeNotification": ExConversationChangeNotification;
  "routing.routingTaskNotification": RoutingTaskNotification;
  "routing.agentStateNotification": AgentStateNotification;
}

export type AgentNotificationsType = "ms.MessagingEventNotification" | "cqm.ExConversationChangeNotification" | "routing.routingTaskNotification" | "routing.agentStateNotification";

export const AgentNotificationsEvents = ["MessagingEventNotification", "ExConversationChangeNotification", "routingTaskNotification", "agentStateNotification"], AgentNotificationsTypes = ["ms.MessagingEventNotification", "cqm.ExConversationChangeNotification", "routing.routingTaskNotification", "routing.agentStateNotification"];

export type AgentNotificationsConstructor<T extends INotificationHandler<IAgentNotificationsType, AgentNotifications>> = new (...args: any[]) => T;
export type AgentNotificationsWrapperConstructor = new (...args: any[]) => IAgentNotificationsWrapper;

export interface IAgentNotificationsWrapper {
  onMessagingEventNotification(cb: (notification: MessagingEventNotification) => void): void;
  onExConversationChangeNotification(cb: (notification: ExConversationChangeNotification) => void): void;
  onRoutingTaskNotification(cb: (notification: RoutingTaskNotification) => void): void;
  onAgentStateNotification(cb: (notification: AgentStateNotification) => void): void;
}

export function wrapAgentNotifications<T extends AgentNotificationsConstructor<INotificationHandler<IAgentNotificationsType, AgentNotifications>>>(Base: T): T & AgentNotificationsWrapperConstructor {

  class AgentNotificationsWrapper extends Base implements IAgentNotificationsWrapper {
    constructor(...args) {
      super(...args);
    }

    public onMessagingEventNotification(cb: (notification: MessagingEventNotification) => void): void {
      this.onNotification(AgentNotificationsEvent.MessagingEventNotification, cb);
    }

    public onExConversationChangeNotification(cb: (notification: ExConversationChangeNotification) => void): void {
      this.onNotification(AgentNotificationsEvent.ExConversationChangeNotification, cb);
    }

    public onRoutingTaskNotification(cb: (notification: RoutingTaskNotification) => void): void {
      this.onNotification(AgentNotificationsEvent.routingTaskNotification, cb);
    }

    public onAgentStateNotification(cb: (notification: AgentStateNotification) => void): void {
      this.onNotification(AgentNotificationsEvent.agentStateNotification, cb);
    }
  }
  return AgentNotificationsWrapper;
}
