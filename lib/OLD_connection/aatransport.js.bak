"use strict";
const WebSocket = require("ws");
const Events = require("events");

const { Event, Errors } = require("../shared/const");
const Logger = {
  // TODO: remove this asa the Logger is working again
  log: console.log,
  info: console.info,
  warn: console.warn,
  debug: console.debug,
  verbose: console.debug,
  error: console.error
};
const Util = require("../shared/util");

/**
 * WS constants taken from https://github.com/websockets/ws/blob/master/doc/ws.md
 */
const WS_CONSTS = { // TODO: inherit! Once I figured out how this works in TS
  /**
   * Internal, lib-specific events
   */
  WSEvents: {
    OPEN: "open",
    CONNECTED: "connected",
    CLOSE: "close",
    ERROR: "error",
    MESSAGE: "message",
    HEADERS: "headers",
    PING: "ping",
    PONG: "pong",
    UNEXPECTED_RESPONSE: "unexpected-response"
  }
};

/**
 * The connections strategies determine whether the websocket should be opened only for sending a single message or kept open until it is closed by close()
 */
const ConnectionStrategies = {// TODO: inherit! Once I figured out how this works in TS
  LEAVE_OPEN: "transport.LEAVE_OPEN",
  IMMEDIATE: "transport.IMMEDIATE"
};

const DEFAULT_CONF = {// TODO: inherit! Once I figured out how this works in TS
  apiVersion: 2,
  connectionStrategy: ConnectionStrategies.LEAVE_OPEN,
  pingInterval: 60000 /* in secs */,
  logClientPfx: "C/A",
  logServerPfx: "UMS"
};

/**
 * Handler for WebSocket connections. As the underlying library we use https://github.com/websockets/ws/
 * The Transport object can be conifgured by the following means:
 * - ConnectionStrategy
 * - Timeout handling
 * - Kill old ws on subsequent connect() call
 * - TODO: add and explain
 * 
 * @class Transport
 * @extends {Events}
 */
class AATransport extends Events {
  /**
   * Creates an instance of Transport.
   * 
   * The config object should look like this:
   * {
   *   domain: this.domains.asyncMessagingEnt,
   *   token:  token
   * }
   * 
   * @param {any} config 
   * @memberof Transport
   */
  constructor(config) {
    super();
    /**
     * this.ws holds the WebSocket connection. It is NULL iff. the WebSocket object has not been created yet OR dispose() has been called.
     */
    this.ws = null;

    /**
     * Publicly exposed events, the user can listen on
     * 
     * @memberof Transport
     */
    this.Event = {
      ON_RECONNECTING: "transport.ON_RECONNECTING",
      ON_MESSAGE: "transport.ON_MESSAGE",
      ON_ERROR: "transport.ON_ERROR",
      ON_CLOSED: "transport.ON_CLOSED",
      ON_CONNECTED: "transport.ON_CONNECTED"
    };

    /**
     * 
     */
    this._conf = Object.assign(DEFAULT_CONF, config);

    /**
     * A sending queue that buffers messages in case the websocket is down
     */
    this.sendingQueue = [];
  }

  connect(wsUrl = Util.getWebsocketUri(this._conf), killOld = true) {
    if (this.ws && killOld) {
      Logger.warn(`Transport.connect() called with killOld = ${killOld}. Now terminating old socket...`);
      this.disconnect(false);
    }

    Logger.verbose(`Connecting websocket on URL '${wsUrl}'...`);

    this.ws = new WebSocket(wsUrl);
    /**
     * Add the event hooks
     */
    this.ws.on(Event.OPEN, () => {
      Logger.info(`${this._conf.logClientPfx} <---> ${this._conf.logServerPfx} (Connection established)`);
      this.onConnected();
    });
    this.ws.on(Event.CLOSE, (code, reason) => {
      Logger.info(`${this._conf.logClientPfx} <---> ${this._conf.logServerPfx} --X-- UMS (%s %s)`, code, reason);
      this.onClosed(code, reason);
    });
    this.ws.on(Event.ERROR, err => {
      Logger.error(`${this._conf.logClientPfx} <---> ${this._conf.logServerPfx} -Err- UMS (%j)`, err);
      this.onError(err);
    });
    this.ws.on(Event.MESSAGE, data => {
      Logger.info(`${this._conf.logClientPfx} <---> ${this._conf.logServerPfx} <---- UMS (Message received)`);
      Logger.debug("Payload:", data);
      this.onMessage(data);
    });
    this.ws.on(WS_CONSTS.WSEvents.UNEXPECTED_RESPONSE, (req, res) => {
      Logger.info(`${this._conf.logClientPfx} <---> ${this._conf.logServerPfx} --?-- UMS (Unexpected response)`);
      Logger.debug("Unexpected response %s %s", req, res);
    });
  }

  async connectAsync(wsUrl, killOld) {
    const that = this;
    return new Promise((res, rej) => {
      const reshandler = function(e) {
        removeHandlers();
        return res(e);
      };
      const errhandler = function(e) {
        removeHandlers();
        return rej(e);
      };
      const removeHandlers = function() {
        that.removeListener(that.Event.ON_CONNECTED, reshandler);
        that.removeListener(that.Event.ON_ERROR, errhandler);
      };
      that.on(that.Event.ON_CONNECTED, reshandler);
      that.on(that.Event.ON_ERROR, errhandler);
      that.connect(wsUrl, killOld);
    });
  }

  reconnect() {
    this.emit(ON_RECONNECTING);
    this.disconnect();
    this.connect();
  }

  /**
   * 
   * 
   * @memberof Transport
   */
  disconnect() {
    Logger.info("Disconnecting socket connection...");
    if (this.sendingQueue.length > 0) {
      Logger.warn(`Flushing messages from websocket queue! ${this.sendingQueue.length} messages will be discarded...`);
      this.sendingQueue = [];
    }

    clearTimeout(this.heartbeatID);
    if (this.ws) {
      this.ws.close();
    }
  }

  async disconnectAsync() {
    const that = this;
    return new Promise((res, rej) => {
      const reshandler = function(e) {
        removeHandlers();
        return res(e);
      };
      const errhandler = function(e) {
        removeHandlers();
        return rej(e);
      };
      const removeHandlers = function() {
        that.removeListener(that.Event.ON_CLOSED, reshandler);
        that.removeListener(that.Event.ON_ERROR, errhandler);
      };
      that.on(that.Event.ON_CLOSED, reshandler);
      that.on(that.Event.ON_ERROR, errhandler);
      that.disconnect();
    });
  }

  async sendAsync(rawMsg, timoutInMs, maxRetries) {
    const that = this;
    return new Promise((resolve, reject) => {

      const errhandler = function(e) {
        removeHandlers();
        return reject(e);
      };
      const removeHandlers = function() {
        that.removeListener(that.Event.ON_ERROR, errhandler);
      };
      that.on(that.Event.ON_ERROR, errhandler);
      that.send(
        rawMsg,
        (err, res) => {
          removeHandlers();
          if (err) return reject(err);
          resolve();
        },
        timoutInMs,
        maxRetries
      );
    });
  }

  /**
   * 
   * 
   * @param {any} rawMsg string message to be sent over the ws
   * @param {any} cb callback with (err)
   * @memberof Transport
   */
  send(rawMsg, cb, timoutInMs, maxRetries) {
    if (this._conf.connectionStrategy === ConnectionStrategies.IMMEDIATE) {
      /**
       * If the strategy is set to ConnectionStrategies.IMMEDIATE, the connection is only opened for sending the message and closed directly after
       * For this, we hijack the callback and put a "middleware" in it
       */
      this.connect();
      let tmpCb = cb;
      cb = (err, res) => {
        this.disconnect();
        tmpCb(err, res);
      };
    }

    this._waitForSocketConnection(
      this.ws,
      (err, res) => {
        if (err) return cb(err);

        Logger.info(`${this._conf.isConsumer ? "Consumer C" : "Agent A"} ----> UMS (sending)`);
        Logger.verbose(rawMsg);

        this.ws.send(rawMsg, err => {
          if (err) Logger.error("Unable to send message over websocket! Err: " + err);
          cb(err);
        });
      },
      timoutInMs,
      maxRetries
    );
  }

  onMessage(rawMsg) {
    this.emit(this.Event.ON_MESSAGE, rawMsg);
  }

  onConnected() {
    this.emit(this.Event.ON_CONNECTED);
    if (this.ws == null || this.ws.readyState !== WebSocket.OPEN) {
      return new Error(`THIS STATE SHOULD NOT OCCUR! ws = ${this.ws} state = ${this.ws.readyState}`);
    }
  }

  onClosed(code, reason) {
    clearTimeout(this.heartbeatID);
    // this.ws = null;
    this.emit(this.Event.ON_CLOSED, { code: code, reason: reason });
  }

  onError(err) {
    clearTimeout(this.heartbeatID);
    this.emit(this.Event.ON_ERROR, err);
  }

  heartBeatCheck(verifyWithPong = true) {
    const proceed = () => {
      Logger.verbose("");
      this.heartbeatID = setTimeout(() => {
        this.heartBeatCheck();
      }, this._conf.pingInterval);
    };

    clearTimeout(this.heartbeatID);
    if (verifyWithPong) {
      const pongTimeout = 100;
      const waitForPong = setTimeout(() => {
        this.onError(`No pong received after waiting ${pongTimeout}ms!`);
      }, pongTimeout /* waiting for a pong */);
      this.ws.on(WS_CONSTS.WSEvents.PONG, () => {
        clearTimeout(waitForPong);
        proceed();
      });
      this.ws.ping();
    } else {
      this.ws.ping();
      proceed();
    }
  }

  // Make the function wait until the connection is made...
  _waitForSocketConnection(socket, callback, timoutInMs = 50, maxRetries = 10) {
    if (maxRetries < 0) {
      return callback("Waited for sockets to reconnect. Max timeout reached!", null);
    }
    if (this.ws.readyState === WebSocket.OPEN) {
      if (callback != null) {
        callback();
      }
      return;
    } else {
      const that = this;
      setTimeout(function() {
        that._waitForSocketConnection(socket, callback, timoutInMs, --maxRetries);
      }, timoutInMs);
    }
  }
}

module.exports = {
  AATransport,
  ConnectionStrategies
};
