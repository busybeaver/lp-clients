import { Transport, TransportConfig } from "./transport";
import { ILogger, ConsoleLogger, ITransport } from "../shared/const";

const WebSocket = require("ws");
/**
 * Handler for WebSocket connections. As the underlying library we use https://github.com/websockets/ws/
 *
 *
 * @class Transport
 * @extends {Events}
 */
export class UMSTransport<SendType, ReceiveType> extends Transport implements ITransport<SendType, ReceiveType> {

  constructor(conf?: TransportConfig, logger: ILogger = new ConsoleLogger("UMSTransport")) {
    super(conf, logger);
  }


  /** true if the transport is connected; else false */
  public isConnected(): boolean {
    return this.ws !== undefined && this.ws.readyState === WebSocket.CONNECTED;
  }

  /**
   * connects the transport to the endpoint. the promise resolves in
   * case of a successful connect; else the promise rejects. if the
   * transport is already connected, the promise instantly resolves.
   */
  public connectWPromise(): Promise<void> {

    return null;
  }
  /**
   * disconnects the transport to the endpoint. the promise resolves in
   * case of a successful disconnect; else the promise rejects. if the
   * transport is already disconnected, the promise instantly resolves.
   */
  disconnectWPromise(): Promise<void> {
    // TODO assemble message
    return null;
  }
  /**
   * sends a message/event/object to the endpoint. the promise resolves in
   * case of successful sending; else the promise rejects.
   * @param obj the message/event/object which should be sent
   */
  sendWPromise(obj: SendType): Promise<void> {
    const that = this;
    return new Promise((res, rej) => {
      that.sendWithCb(err => {
        if (err) return rej(err);
        res();
      }, obj + "");
    });
  }
  /**
   * called in case of incoming messages/events/objects
   * @param cb the callback which is called on incoming data
   */
  onMessageCallback(cb: (err?: Error, res?: ReceiveType) => void): void {}

  /**
   * called in case of general transport errors like errors that happen
   * not in the context of a specific send/receive/connect/etc. context
   * (in case of errors during sending/receiving, the error callback/
   * promise.reject should be used)
   * @param cb the callback which is called in case of errors.
   */
  onErrorCallback(cb: (err: Error) => void): void {}
}
