"use strict";
const uuidV4 = require("uuid/v4");
const Events = require("events");
const WebSocket = require("ws");

const { Observable, State, StateHandler, StateObserver, Transition } = require("./shared/statefull");
const { Event, Types, Errors, Agent_Requests } = require("./shared/const");
const Logger = require("./shared/const").Logger.Client;
const RLogger = require("./shared/const").Logger.Websocket;
const Util = require("./shared/util");
const Transport = require("./connection/transport");
const External = require("./connection/external-services");

function _ValidateConfig(config) {
  //TODO: Use Schema Validator
  if (!config.accountId) {
    throw new Error("missing accountId param");
  }
  if (
    !config.token &&
    (!config.username || !config.password) &&
    !config.assertion &&
    (!config.username || !config.appKey || !config.secret || !config.accessToken || !config.accessTokenSecret)
  ) {
    throw new Error(
      "missing token or user/password or assertion or appKey/secret/accessToken/accessTokenSecret params"
    );
  }
}

function _EnsureIsError(potentialError) {
  if (potentialError instanceof Error) {
    return potentialError;
  } else if (typeof potentialError === "string") {
    return new Error(potentialError);
  } else {
    return new Error(JSON.stringify(potentialError, null, 2));
  }
}

class Agent extends Events {
  constructor(config) {
    super();
    _ValidateConfig(config);
    this.init(config);
  }

  init(config) {
    // Initializing Members
    this.retries = 0;
    this.requestTimeout = 1; // 3 Minutes
    this.instanceID = uuidV4(); // Used for Debugging
    this.transport = null;
    this.domains = null;
    this.connected = false;
    this.userId = null;
    this.oldId = null;
    this.subscriptions = [];
    this.pendingRequests = [];
    this.sendingQueue = [];

    this.refreshInterval = config.refreshSessionInterval || 60000 * 10; //10 min
    this.watchInterval = 1000 * 2; // 2 Sekunden
    this.config = config;
    this.observable = new StateHandler(
      State.INITIALIZED,
      new StateObserver(Observable.ON_INIT, this.onConnected.bind(this)),
      new StateObserver(Observable.ON_IDLE, this.onIdle.bind(this)),
      new StateObserver(Observable.ON_ERR, this.onError.bind(this)),
      new StateObserver(Observable.ON_CON, this.onConnected.bind(this))
    );
  }

  //-- State Observer Callbacks --//

  onInitialized() {
    Logger.info("Created Agent instance %s using the following conf %j", this.instanceID, config);
  }

  onConnected(hasRecovered) {
    Logger.info("Connected instance " + this.instanceID);
    Logger.info("Connected before? " + this.connected);
    this.connected = true;

    if (hasRecovered) {
      Logger.info("Agent instance %s successfully recovered from err", this.instanceID);
      this.retries = 0;
      // this._DeliverQueuedMessages();
    } else {
      Logger.info("Agent instance %s successfully authorized and connected to the UMS", this.instanceID);
      this.emit(Event.CONNECTED, { ts: Date.now() });
    }
    this._DeliverQueuedMessages();
    this._ScheduleTasks();
  }

  onIdle(hasFailed, fatalErr) {
    this.connected = false;
    if (hasFailed) {
      this.emit(Event.ERROR, fatalErr);
      Logger.info(`Agent instance %s is now in idle state due to fatal error %s`, this.instanceID, fatalErr.message);
      this.dispose();
    } else {
      Logger.info("Agent instance %s successfully obtained an token", this.instanceID);
    }
  }

  onClosed(msg) {
    const { code, reason } = msg;

        /**
     * WS implementation status codes, see https://tools.ietf.org/html/rfc6455#section-7.4.1
     */
    switch (code) {
      /*case 1000: // normal closure
      case 1001: // endpoint went down
      case 1002: // endpoint terminated, protocol error
      case 1003: // endpoint is terminating the connection because it has received a type of data it cannot accept
      case 1004: // Reserved
      case 1005: // Reserved
      case 1401: // Custom; Unauthorized
        break;*/
      case 1006: // Reserved BUT "indicate that the connection was closed abnormally"
        /**
         * For the agent, 1006 is NOT fatal!
         */
        Logger.warn("Agent onClose() successful, we've got a ${code}");
        break;
      default:
      // do nothing
    }

    if (this.observable.state === State.CONNECTED) {
      // Message Related Errors
      switch (code) {
        default:
          this.observable.transite(Transition.ERRORING, new Error(`${code} ${reason}`));
          break;
      }
    } else if (this.observable.state === State.IDLE) {
      // Login Related Errors
      this.onErrored(new Error(`${code} ${reason}`));
    } else {
      // Just Drop
      this.onErrored(new Error(`${code} ${reason}`));
    }
  }

  onError(err) {
    err = this.retries >= 3 ? new Error(Errors.FATAL.MAX_RETRIES_REACHED) : _EnsureIsError(err);
    // Determine kind of error
    let { isFatal, recoveryStrategy } = this._DetermineIfErrorIsFatal(err);

    if (isFatal) {
      Logger.error("Agent instance %s experienced the following fatal error: %s", this.instanceID, err.message, {
        error: err.message,
        stacktrace: err.stack
      });
      this.observable.transite(Transition.FAILING, true, err);
    } else {
      this.retries += 1;
      Logger.warn(
        "Agent instance %s experienced following error: %s and is now recovering",
        this.instanceID,
        err.message,
        { retries: this.retries }
      );
      recoveryStrategy();
      this.observable.transite(Transition.RECOVERED, true);
    }
  }

  onAuthFailed(err) {
    Logger.error(
      "Agent instance %s experienced the following fartal error: %s during login",
      this.instanceID,
      err.message,
      { error: err.message, stacktrace: err.stack }
    );
    this.emit(Event.ERROR, err);
    this.dispose();
  }

  //-- Public --//

  connect() {
    const { accountId, csdsDomain } = this.config;
    External.resolveAgentDomains(accountId, csdsDomain)
      .then(domains => this._Login(domains), err => this.onAuthFailed(err))
      .then(token => this._Connect(token, false), err => this.onAuthFailed(err))
      .catch(err => this.observable.transite(Transition.ERRORING, err));
  }

  setAgentState(isOnline = true) {
    let body = {
      availability: isOnline ? "ONLINE" : "OFFLINE",
      channels: ["MESSAGING"],
      agentUserId: this.oldId
    };
    return this._SendingMessage(Agent_Requests.UPDATE_AGENT_STATE, body, null);
  }

  startDialog(convId, dialog = "COBROWSE") {
    let body = {
      conversationId: convId,
      conversationField: [
        {
          field: "DialogChange",
          type: "CREATE",
          dialog: {
            dialogType: "OTHER",
            channelType: dialog
          }
        }
      ]
    };
    return this._SendingMessage(Agent_Requests.UPDATE_COV, body, null);
  }

  sendMessage(msg, convId) {
    let body = {
      dialogId: convId,
      event: {
        type: "ContentEvent",
        contentType: "text/plain",
        message: msg
      }
    };
    return this._SendingMessage(Agent_Requests.PUBLISH, body, null);
  }

  sendRichContent(msg, convId = this.conversationId) {
    let body = {
      dialogId: convId,
      event: {
        type: "RichContentEvent",
        content: msg
      }
    };
    return this._SendingMessage(Consumer_Requests.PUBLISH, body, null);
  }

  joinConversation(convId, role = "ASSIGNED_AGENT") {
    let body = {
      conversationId: convId,
      conversationField: [
        {
          field: "ParticipantsChange",
          type: "ADD",
          role: role,
          userId: this.oldId
        }
      ]
    };
    return this._SendingMessage(Agent_Requests.UPDATE_COV, body, null);
  }

  leaveConversation(convId) {
    let body = {
      conversationId: convId,
      conversationField: [
        {
          field: "ParticipantsChange",
          type: "REMOVE",
          role: "ASSIGNED_AGENT",
          userId: this.oldId
        }
      ]
    };
    return this._SendingMessage(Agent_Requests.UPDATE_COV, body, null);
  }

  acceptRing(ringId) {
    let body = {
      ringId: ringId,
      ringState: "ACCEPTED"
    };
    return this._SendingMessage(Agent_Requests.UPDATE_RING_STATE, body, null);
  }

  transferConversation(convId, newskill, role = "ASSIGNED_AGENT") {
    let body = {
      conversationId: convId,
      conversationField: [
        {
          field: "Skill",
          type: "UPDATE",
          skill: newskill
        },
        {
          field: "ParticipantsChange",
          type: "REMOVE",
          role: role,
          userId: this.oldId
        }
      ]
    };
    return this._SendingMessage(Agent_Requests.UPDATE_COV, body, null);
  }

  closeConversation(convId) {
    let body = {
      conversationId: convId,
      conversationField: [
        {
          field: "ConversationStateField",
          conversationState: "CLOSE"
        }
      ]
    };

    return this._SendingMessage(Agent_Requests.UPDATE_COV, body, null);
  }

  subscribeConversations(onlyAgentConvs = false) {
    let body = {
      convState: ["OPEN"],
      agentIds: onlyAgentConvs ? [this.oldId] : null
    };
    return this._SendingMessage(Agent_Requests.SUBSCRIBE_CONV, body, null);
  }

  subscribeRoutingTask() {
    let body = {
      channelType: "MESSAGING",
      agentId: this.oldId,
      brandId: this.accountId
    };
    return this._SendingMessage(Agent_Requests.ROUTING_TASK, body, null);
  }

  subscribeMessages(convId, start = 0) {
    let body = {
      dialogId: convId,
      newerThanSequence: start
    };
    return this._SendingMessage(Agent_Requests.SUBSCRIBE_MSGS, body, null);
  }

  getUserProfile(userid) {
    return this._SendingMessage(Agent_Requests.USER_PROFILE, userid, null);
  }

  registerSubscriptionBasedOnFilter(filter, cb) {
    cb = typeof cb === "function" ? cb : () => {};
    this.subscriptions.push({ filter: filter, callback: cb });
  }

  dispose() {
    this.connected = false;
    // Stop ongoing tasks
    clearTimeout(this.RefreshTask);
    clearTimeout(this.PendingTask);

    // Clear Socket
    this._Disconnect();

    // Clear own listeneres
    this.removeAllListeners();
  }

  //-- Private --//

  _Login(domains) {
    this.domains = domains;
    if (this.config.token) {
      const { userId, accountId, userPid } = this.config;
      this.userId = userId;
      this.agentId = userPid;
      this.oldId = `${accountId}.${userId}`; //for external use
      return Promise.resolve(this.config.token);
    } else {
      let loginData = Object.assign({ domain: domains.agentVep }, this.config);
      return External.login(loginData).then(
        result => Promise.resolve(this._UpdateLoginInformation(result.data, result.cookies)),
        err => Promise.reject(err)
      );
    }
  }

  _UpdateLoginInformation(data, cookies) {
    if (data && data.config) {
      this.accountId = this.config.accountId;
      this.oldId = `${this.config.accountId}.${data.config.userId}`; //for external use
      this.userId = data.config.userId; //for internal use
      this.agentId = data.config.userPid;

      if (data.csrf) {
        this.jar = cookies;
        this.csrf = data.csrf;
      }
      return data.bearer;
    } else {
      return "";
    }
  }

  _ReceivedMessage(err, msg) {
    if (err) {
      return Logger.error("REC %s ERROR A<---- '%s'", this.instanceID, err);
    }
    Logger.debug("REC %s MESSAGE A<---- %j", this.instanceID, msg);
    if (msg && msg.kind === Types.RESPONSE) {
      this._HandleResponse(msg);
    } else if (msg.kind === Types.NOTIFICATION) {
      this._HandleNotification(msg);
    } else {
      Logger.warn("REC %s UNKNOWN A<---- %j", this.instanceID, msg);
    }
  }

  _SendingMessage(type, msg, headers) {
    let request = {
      kind: Types.REQUEST,
      id: uuidV4(),
      type: type,
      body: msg || {},
      headers: headers
    };

    const instance = this.instanceID;
    const hardRejectsLevel = this.hardRejectsLevel;

    return new Promise((resolve, reject) => {
      this.pendingRequests[request.id] = {
        start: Date.now(),
        cb: function(type, code, response) {
          Logger.debug("REC %s REQUEST A<---- Request %s '%s' code '%s'", instance, request.type, request.id, code.toString());

          /**
           * Adding hardReject array
           */
          if (hardRejectsLevel !== undefined && hardRejectsLevel <= code) {
            //if (hardRejects !== undefined && hardRejects.length !== undefined && hardRejects.length > 0 && hardRejectscode.indexOf(code) > -1) {
              return reject({
                code: code,
                type: type,
                body: response
              });
            }

          return resolve({
            code: code,
            type: type,
            body: response
          });
        }
      };

      if (this.transport && this.transport.state() === WebSocket.OPEN) {
        // RLogger.debug("Send Agent: Request %s", request.id);
        Logger.debug("SEN %s REQUEST A----> Request %s '%s'", instance, request.type, request.id);
        this.transport.send(request);
      } else {
        Logger.debug("SEN %s MESSAGE Ax----> Request '%s' Unable to send! WS not ready '%s'!", instance, request.id, this.transport ? this.transport.state() : "UNDEFINED!");
        this.sendingQueue.push(request);
        this.observable.transite(Transition.ERRORING, new Error(Errors.NOT_FATAL.MESSAGE_COULD_NOT_BE_SEND));
      }
    });
  }

  _HandleNotification(notification) {
    this.subscriptions
      .filter(sub => sub.filter(notification))
      .forEach(sub => sub.callback(notification.type, notification.code, notification.body));
  }

  _HandleResponse(response) {
    let { reqId } = response;

    delete response.reqId;
    delete response.kind;

    if (this.pendingRequests[reqId]) {
      this.pendingRequests[reqId].cb(response.type, response.code, response.body);
      delete this.pendingRequests[reqId];
    }
  }

  _Connect(token = this.token, recovered = true) {
    if (typeof token !== "string" || token === "") {
      throw new Error(Errors.NOT_FATAL.COULD_NOT_GENERATE_TOKEN);
    } else {
      this.observable.transite(Transition.AUTHORIZING, false);
      this.token = token;

      const options = Object.assign(
        {
          domain: this.domains.asyncMessagingEnt,
          token: token
        },
        this.config
      );
      
      this.transport = new Transport(options);
      this.transport.on(Event.OPEN, () => this.observable.transite(Transition.CONNECTING, recovered));
      this.transport.on(Event.CLOSE, reason => this.onClosed(reason));
      this.transport.on(Event.ERROR, err => this.observable.transite(Transition.ERRORING, err));
      this.transport.on(Event.MESSAGE, (err, res) => this._ReceivedMessage(err, res));
      this.transport.connect();
    }
  }

  _Disconnect() {
    if (this.transport) {
      this.transport.removeAllListeners();
      this.transport.disconnect();
    }
    this.transport = null;
  }

  _RefreshSession(err, data) {
    if (err) {
      Logger.error("Following error occured during agent session refresh: %s", err.message);
      this.onError(new Error(Errors.NOT_FATAL.REFRESH_FAILED));
    } else if (this.csrf) {
      clearTimeout(this.RefreshTask);
      Logger.info("Scheduling RefreshTask every %s ms", this.refreshSessionInterval);
      this.RefreshTask = setTimeout(
        () =>
          External.refreshSession(
            {
              accountId: this.accountId,
              domain: this.domains.agentVep,
              csrf: this.csrf,
              jar: this.jar
            },
            () => this._RefreshSession()
          ),
        this.refreshSessionInterval
      );
    }
  }

  _PendingRequestTask() {
    for (let i = 0; i < this.pendingRequests.length; i++) {
      if (Util.difBetweenTsInMinutes(Date.now(), pending.start) > this.requestTimeout) {  // TODO: there is no pending property defined here?!?
        this.pendingRequests[i].cb(Types.RESPONSE, 408, {});
        this.pendingRequests[i] = null;
      }
    }
    Util.cleanArray(this.pendingRequests);
  }

  _ScheduleTasks() {
    clearTimeout(this.PendingTask);
    Logger.info("Scheduling PendingRequestTask every %s ms", this.watchInterval);
    this.PendingTask = setTimeout(this._PendingRequestTask.bind(this), this.watchInterval);
    if (this.csrf && this.jar) {
      //this._RefreshSession();
    }
  }

  _DeliverQueuedMessages() {
    if (this.sendingQueue.length == 0) {
      Logger.info("No queued messages to send! Skipping...");
      return;
    }
    Logger.info("Sending %s messages that queued up", this.sendingQueue.length);
    this.sendingQueue.forEach(request => this.transport.send(request));
    this.sendingQueue = [];
  }

  _DetermineIfErrorIsFatal(err) {
    let result = { isFatal: false, recoveryStrategy: () => {} };

    switch (err.message) {
      case Errors.NOT_FATAL.MESSAGE_COULD_NOT_BE_SEND:
        result.recoveryStrategy = function() {
          //Determine if data is missing
          //=> Just reconnect the transportation
          //=> Obtain missing data
          // Clear Socket
          this._Disconnect();
          // Reconnect
          this._Connect();
        }.bind(this);
        break;
      case Errors.FATAL.ERR_DESERIALIZING:
        result.isFatal = true;
        return;
      case Errors.NOT_FATAL.COULD_NOT_GENERATE_TOKEN:
        result.recoveryStrategy = function() {
          // Clear Socket
          this._Disconnect();
          // Retry Login
          this.connect();
        }.bind(this);
        break;
      case Errors.NOT_FATAL.COULD_NOT_PARSE_MSG:
        // Should Never Happend
        result.isFatal = true;
        break;
      default:
        result.isFatal = true;
        break;
    }
    return result;
  }
}
module.exports = Agent;
