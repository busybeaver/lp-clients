"use strict";
const uuidV4 = require("uuid/v4");
const Events = require("events");
const WebSocket = require("ws");

const { Observable, State, StateHandler, StateObserver, Transition } = require("./shared/statefull");
const { Event, Types, Errors, Consumer_Requests } = require("./shared/const");
const Logger = require("./shared/const").Logger.Client;
const RLogger = require("./shared/const").Logger.Websocket;
const Util = require("./shared/util");
const Transport = require("./connection/transport");
const External = require("./connection/external-services");

function _ValidateConfig(config) {
  //TODO: Use Schema Validator
}

function _EnsureIsError(potentialError) {
  if (potentialError instanceof Error) {
    return potentialError;
  } else if (typeof potentialError === "string") {
    return new Error(potentialError);
  } else {
    return new Error(JSON.stringify(potentialError, null, 2));
  }
}

class Consumer extends Events {
  constructor(config) {
    super();
    _ValidateConfig(config);
    this.init(config);
  }

  init(config) {
    // Initializing Members
    this.accountId = config.accountId;
    this.instanceID = uuidV4(); // Used for Debugging
    this.retries = 0;
    this.requestTimeout = 3; // 3 Minutes
    this.connected = false;
    this.transport = null;
    this.conversationId = null;
    this.userId = null;
    this.token = null;
    this.properties = null;
    this.subscriptions = [];
    this.pendingRequests = [];
    this.sendingQueue = [];

    this.watchInterval = 1000 * 2; // 2 Sekunden
    this.observable = new StateHandler(
      State.INITIALIZED,
      new StateObserver(Observable.ON_INIT, this.onConnected.bind(this)),
      new StateObserver(Observable.ON_IDLE, this.onIdle.bind(this)),
      new StateObserver(Observable.ON_ERR, this.onError.bind(this)),
      new StateObserver(Observable.ON_CON, this.onConnected.bind(this))
    );
  }

  //-- State Observer Callbacks --//

  onInitialized() {
    Logger.info("Created Consumer instance %s using the following conf %j", this.instanceID, config);
  }

  onConnected(hasRecovered) {
    this.connected = true;

    if (hasRecovered) {
      this.authorize(this.properties, hasRecovered)
        .then(
          () => {
            this.retries = 0;
            this._DeliverQueuedMessages();
          },
          err => this.observable.transite(Transition.FAILING, err)
        )
        .catch(err => this.observable.transite(Transition.FAILING, err));
      Logger.info("Consumer instance %s successfully recovered from err", this.instanceID);
    } else {
      Logger.info(
        "Consumer instance %s successfully authorized and connected to the UMS using the following properties: %j",
        this.instanceID,
        this.properties
      );
      this.emit(Event.CONNECTED, { ts: Date.now() });
    }

    this._ScheduleTasks();
  }

  onIdle(hasFailed, fatalErr) {
    this.connected = false;
    if (hasFailed) {
      this.emit(Event.ERROR, fatalErr);
      Logger.info(`Consumer instance %s is now in idle state due to fatal error %s`, this.instanceID, fatalErr.message);
      // this.dispose();
    } else {
      Logger.info("Consumer instance %s successfully obtained an token", this.instanceID);
    }
  }

  onError(err) {
    err = this.retries >= 3 ? new Error(Errors.FATAL.MAX_RETRIES_REACHED) : _EnsureIsError(err);

    // Determine kind of error
    let { isFatal, recoveryStrategy } = this._DetermineIfErrorIsFatal(err);

    if (isFatal) {
      Logger.error("Consumer instance %s experienced the following fatal error: %s", this.instanceID, err.message, {
        error: err.message,
        stacktrace: err.stack
      });
      this.observable.transite(Transition.FAILING, true, err);
      this.dispose();
      return;
    } else {
      this.retries += 1;
      Logger.warn(
        "Consumer instance %s experienced following error: %s and is now recovering",
        this.instanceID,
        err.message,
        { retries: this.retries }
      );
      recoveryStrategy();
      this.observable.transite(Transition.RECOVERED, true);
    }
  }

  onClosed(msg) {
    const { code, reason } = msg;

    /**
     * WS implementation status codes, see https://tools.ietf.org/html/rfc6455#section-7.4.1
     */
    switch (code) {
      /*case 1000: // normal closure
      case 1001: // endpoint went down
      case 1002: // endpoint terminated, protocol error
      case 1003: // endpoint is terminating the connection because it has received a type of data it cannot accept
      case 1004: // Reserved
      case 1005: // Reserved
      case 1401: // Custom; Unauthorized
        break;*/
      case 1006: // Reserved BUT "indicate that the connection was closed abnormally"
        /**
         * For the consumer, 1006 is FATAL!
         */
        this.observable.transite(
          Transition.ERRORING,
          new Error(`${code} WS-internal code indicating the connection was closed abnormally`),
          true /*fatal*/
        );
        return;
      default:
      // do nothing
    }

    if (this.observable.state === State.CONNECTED) {
      // Message Related Errors
      switch (code) {
        default:
          this.observable.transite(Transition.ERRORING, new Error(`${code} ${reason}`));
          break;
      }
    } else {
      this.observable.transite(Transition.ERRORING, new Error(`${code} ${reason}`));
    }
  }

  onAuthFailed(err) {
    Logger.error(
      "Consumer instance %s experienced the following fartal error: %s during login",
      this.instanceID,
      err.message,
      { error: err.message, stacktrace: err.stack }
    );
    this.emit(Event.ERROR, err);
    this.dispose();
  }

  //-- Public --//

  connect() {
    External.resolveConsumerDomains(this.accountId, "idp")
      .then(
        domain =>
          Promise.all([this._Login(domain), External.resolveConsumerDomains(this.accountId, "asyncMessagingEnt")]),
        err => this.onAuthFailed(err)
      )
      .then(
        results => {
          if (results && results.length === 2) this._Connect(results[0], results[1], false);
        },
        err => this.onAuthFailed(err)
      )
      .catch(err => this.observable.transite(Transition.ERRORING, err));
  }

  authorize(properties, recovering) {
    let headers = [{ type: ".ams.headers.ConsumerAuthentication", jwt: this.token }];
    if (properties && typeof properties === typeof {}) headers.push(properties);
    this.properties = properties;
    return this._SendingMessage(Consumer_Requests.INIT_CON, {}, headers).then(
      res => {
        if (recovering) this.observable.transite(Transition.CONNECTING, false);
        return Promise.resolve(res);
      },
      err => Promise.reject(err)
    );
  }

  requestConversation() {
    return this._SendingMessage(Consumer_Requests.REQUEST_CONV, {}, null);
  }
  sendMessage(msg, convId = this.conversationId) {
    let body = {
      dialogId: convId,
      event: {
        type: "ContentEvent",
        contentType: "text/plain",
        message: msg
      }
    };
    return this._SendingMessage(Consumer_Requests.PUBLISH, body, null);
  }

  closeConversation(convId = this.conversationId) {
    let body = {
      conversationId: convId,
      conversationField: [
        {
          field: "ConversationStateField",
          conversationState: "CLOSE"
        }
      ]
    };
    return this._SendingMessage(Consumer_Requests.UPDATE_COV, body, null);
  }

  getAgentProfile(agentId) {
    return External.getAgentProfile(this.accountId, agentId);
  }

  subscribeMessagingEvent(start = 0, convId = this.conversationId) {
    let body = {
      fromSeq: start,
      dialogId: this.conversationId
    };
    return this._SendingMessage(Consumer_Requests.SUBSCRIBE_MESSAGE, body, null);
  }

  subscribeConversation() {
    let body = {
      convState: ["OPEN"]
    };
    return this._SendingMessage(Consumer_Requests.SUBSCRIBE_CONV, body, null);
  }

  registerSubscriptionBasedOnFilter(filter, cb) {
    cb = typeof cb === "function" ? cb : () => {};
    this.subscriptions.push({ filter: filter, callback: cb });
  }

  dispose() {
    this.connected = false;
    // Stop ongoing tasks
    clearTimeout(this.PendingTask);

    // Clear Socket
    this._Disconnect();

    // Clear own listeneres
    // this.removeAllListeners();
  }

  //-- Private --//

  _Login(domain) {
    return this.token
      ? Promise.resolve({ token: this.token, id: JSON.parse(atob(this.token.split(".")[1])).sub })
      : External.generateToken(domain, this.accountId);
  }

  _Connect(loginResponse = { token: this.token, id: this.userId }, msgDomain = this.msgDomain, recovered = true) {
    const { token, id } = loginResponse;

    if (typeof token !== "string" || token === "") {
      throw new Error(Errors.NOT_FATAL.COULD_NOT_GENERATE_TOKEN);
    } else {
      this.observable.transite(Transition.AUTHORIZING, false);
      this.token = token;
      this.userId = id;
      this.msgDomain = msgDomain;

      const options = {
        domain: msgDomain,
        token: token,
        accountId: this.accountId,
        isConsumer: true
      };

      this.transport = new Transport(options);
      this.transport.on(Event.OPEN, () => this.observable.transite(Transition.CONNECTING, recovered));
      this.transport.on(Event.CLOSE, reason => this.onClosed(reason));
      this.transport.on(Event.ERROR, err => this.observable.transite(Transition.ERRORING, err));
      this.transport.on(Event.MESSAGE, (err, res) => this._ReceivedMessage(err, res));

      this.transport.connect();
    }
  }

  _Disconnect() {
    if (this.transport) {
      this.transport.removeAllListeners();
      this.transport.disconnect();
    }
    this.transport = null;
  }

  _ReceivedMessage(err, msg) {
    if (err) {
      return Logger.error("REC %s ERROR C<---- '%s'", this.instanceID, err);
    }
    Logger.debug("REC %s MESSAGE C<---- %j", this.instanceID, msg);

    if (!msg) {
      return Logger.error("REC %s NO MSG C<---- %j", this.instanceID, msg);
    }

    if (msg.kind === Types.RESPONSE) {
      this._HandleResponse(msg);
    } else if (msg.kind === Types.NOTIFICATION) {
      this._HandleNotification(msg);
    } else {
      Logger.warn("REC %s UNKNOWN C<---- %j", this.instanceID, msg);
    }
  }

  _SendingMessage(type, msg, headers) {
    let request = {
      kind: Types.REQUEST,
      id: uuidV4(),
      type: type,
      body: msg || {},
      headers: headers
    };
    const instance = this.instanceID;
    const hardRejectsLevel = this.hardRejectsLevel;

    return new Promise((resolve, reject) => {
      this.pendingRequests[request.id] = {
        start: Date.now(),
        cb: function(type, code, response) {
          //RLogger.debug("Received Consumer: Request %s %s", request.id, code.toString());
          Logger.debug(
            "REC %s REQUEST C<---- Request %s '%s' code '%s'",
            instance,
            request.type,
            request.id,
            code.toString()
          );

          /**
           * Adding hardReject array
           */
          if (hardRejectsLevel !== undefined && hardRejectsLevel <= code) {
          //if (hardRejects !== undefined && hardRejects.length !== undefined && hardRejects.length > 0 && hardRejectscode.indexOf(code) > -1) {
            return reject({
              code: code,
              type: type,
              body: response
            });
          }

          return resolve({
            code: code,
            type: type,
            body: response
          });
        }
      };

      if (this.transport && this.transport.state() === WebSocket.OPEN) {
        // RLogger.debug("Send Consumer: Request %s", request.id);
        // Logger.debug("Send Consumer: Request %s", request.id);
        Logger.debug("SEN %s REQUEST C----> Request %s '%s'", instance, request.type, request.id);
        this.transport.send(request);
      } else {
        Logger.debug(
          "SEN %s MESSAGE Cx----> Request '%s' Unable to send! WS not ready '%s'!",
          instance,
          request.id,
          this.transport ? this.transport.state() : "UNDEFINED!"
        );
        this.sendingQueue.push(request);
        this.observable.transite(Transition.ERRORING, new Error(Errors.NOT_FATAL.MESSAGE_COULD_NOT_BE_SEND));
      }
    });
  }

  _HandleNotification(notification) {
    this.subscriptions
      .filter(sub => sub.filter(notification))
      .forEach(sub => sub.callback(notification.type, notification.code, notification.body));
  }

  _HandleResponse(response) {
    let { reqId } = response;

    delete response.reqId;
    delete response.kind;

    if (this.pendingRequests[reqId]) {
      this.pendingRequests[reqId].cb(response.type, response.code, response.body);
      delete this.pendingRequests[reqId];
    }
  }

  _PendingRequestTask() {
    for (let i = 0; i < this.pendingRequests.length; i++) {
      if (Util.difBetweenTsInMinutes(Date.now(), pending.start) > this.requestTimeout) {
        this.pendingRequests[i].cb(Types.RESPONSE, 408, {});
        this.pendingRequests[i] = null;
      }
    }
    Util.cleanArray(this.pendingRequests);
  }

  _ScheduleTasks() {
    clearTimeout(this.PendingTask);
    Logger.info("Scheduling PendingRequestTask every %s ms", this.watchInterval);
    this.PendingTask = setTimeout(this._PendingRequestTask.bind(this), this.watchInterval);
  }

  _DeliverQueuedMessages() {
    Logger.info("Sending %s messages that queued up", this.sendingQueue.length);
    this.sendingQueue.forEach(request => this.transport.send(request));
    this.sendingQueue = [];
  }

  _DetermineIfErrorIsFatal(err) {
    let result = { isFatal: false, recoveryStrategy: () => {} };

    switch (err.message) {
      case Errors.NOT_FATAL.MESSAGE_COULD_NOT_BE_SEND:
        result.recoveryStrategy = function() {
          //Determine if data is missing
          //=> Just reconnect the transportation
          //=> Obtain missing data
          // Clear Socket
          this._Disconnect();
          // Reconnect
          this._Connect();
        }.bind(this);
        break;
      case Errors.NOT_FATAL.COULD_NOT_GENERATE_TOKEN:
        result.recoveryStrategy = function() {
          // Clear Socket
          this._Disconnect();
          // Retry Login
          this.connect();
        }.bind(this);
        break;
      case Errors.NOT_FATAL.COULD_NOT_PARSE_MSG:
        // Should Never Happend
        result.isFatal = true;
        break;
      default:
        result.isFatal = true;
        break;
    }
    return result;
  }
}
module.exports = Consumer;
